{"version":3,"sources":["webpack:///3.chunk.ddf57.js","webpack:///./node_modules/widgettest/dist/esm/legacy/shadow-css-984bac74-549b16dd.js"],"names":["webpackJsonp","3SdT","module","__webpack_exports__","__webpack_require__","scopeCss","cssText","scopeId","commentOriginalSelector","ShadowCss","shimCssText","stripComments","input","replace","_commentRe","extractCommentsWithHash","match","_commentWithHashRe","processRules","ruleCallback","inputWithEscapedBlocks","escapeBlocks","nextBlockIndex","escapedString","_ruleRe","m","_i","arguments","length","selector","content","suffix","contentPrefix","startsWith","BLOCK_PLACEHOLDER","blocks","substring","rule","CssRule","inputParts","split","_curlyRe","resultParts","escapedBlocks","bracketCount","currentBlockParts","partIndex","part","CLOSE_CURLY","push","join","OPEN_CURLY","StringWithEscapedBlocks","Object","defineProperty","value","d","this","strictStyling","prototype","hostScopeId","slotScopeId","commentsWithHash","orgSelectors","processCommentedSelector_1","placeholder","comment","scopedCssText","_scopeCssText","concat","forEach","_a","_insertPolyfillHostInCssText","_convertColonHost","_convertColonHostContext","_convertColonSlotted","_convertShadowDOMSelectors","_scopeSelectors","trim","_convertColonRule","_cssColonHostRe","_colonHostPartReplacer","slotAttr","_cssColonSlottedRe","compound","_polyfillHostNoCombinator","_cssColonHostContextRe","_colonHostContextPartReplacer","regExp","partReplacer","parts","r","i","p","host","indexOf","_polyfillHost","_shadowDOMSelectorsRe","reduce","result","pattern","scopeSelector","hostSelector","slotSelector","_this","_scopeSelector","strict","map","shallowPart","_selectorNeedsScoping","_applyStrictSelectorScope","_applySelectorScope","_makeScopeMatcher","test","lre","rre","RegExp","_selectorReSuffix","_applySimpleSelectorScope","_polyfillHostRe","lastIndex","replaceBy_1","_polyfillHostNoCombinatorRe","_","before","colon","after","className","_scopeSelectorPart","scopedP","t","matches","safeContent","SafeSelector","res","scopedSelector","startIndex","sep","hasHost","shouldScope","exec","separator","part_1","slice","index","restore","_colonHostContextRe","_polyfillHostContext","_colonHostRe","_colonSlottedRe","_polyfillSlotted","placeholders","keep","replaceBy","_content","pseudo","exp","_parenSuffix"],"mappings":"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","file":"3.chunk.ddf57.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ \"3SdT\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowCss\", function() { return ShadowCss; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scopeCss\", function() { return scopeCss; });\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */\nfunction scopeCss(cssText, scopeId, commentOriginalSelector) {\n    var sc = new ShadowCss();\n    return sc.shimCssText(cssText, scopeId, scopeId + '-h', scopeId + '-s', commentOriginalSelector);\n}\nvar ShadowCss = /** @class */function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    ShadowCss.prototype.shimCssText = function (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) {\n        if (hostScopeId === void 0) {\n            hostScopeId = '';\n        }\n        if (slotScopeId === void 0) {\n            slotScopeId = '';\n        }\n        if (commentOriginalSelector === void 0) {\n            commentOriginalSelector = false;\n        }\n        var commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        var orgSelectors = [];\n        if (commentOriginalSelector) {\n            var processCommentedSelector_1 = function processCommentedSelector_1(rule) {\n                var placeholder = \"/*!@___\" + orgSelectors.length + \"___*/\";\n                var comment = \"/*!@\" + rule.selector + \"*/\";\n                orgSelectors.push({ placeholder: placeholder, comment: comment });\n                rule.selector = placeholder + rule.selector;\n                return rule;\n            };\n            cssText = processRules(cssText, function (rule) {\n                if (rule.selector[0] !== '@') {\n                    return processCommentedSelector_1(rule);\n                } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                    rule.content = processRules(rule.content, processCommentedSelector_1);\n                    return rule;\n                }\n                return rule;\n            });\n        }\n        var scopedCssText = this._scopeCssText(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n        cssText = [scopedCssText].concat(commentsWithHash).join('\\n');\n        if (commentOriginalSelector) {\n            orgSelectors.forEach(function (_a) {\n                var placeholder = _a.placeholder,\n                    comment = _a.comment;\n                cssText = cssText.replace(placeholder, comment);\n            });\n        }\n        return cssText;\n    };\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) {\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertColonSlotted(cssText, slotScopeId);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeId) {\n            cssText = this._scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n        }\n        cssText = cssText.replace(/-shadowcsshost-no-combinator/g, \".\" + hostScopeId);\n        cssText = cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm, ' $1 ');\n        return cssText.trim();\n    };\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n    */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /*\n    * convert a rule like ::slotted(.foo) { }\n    */\n    ShadowCss.prototype._convertColonSlotted = function (cssText, slotAttr) {\n        var regExp = _cssColonSlottedRe;\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var compound = m[2].trim();\n                var suffix = m[3];\n                var sel = '.' + slotAttr + ' > ' + compound + suffix;\n                return sel;\n            } else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n    */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var parts = m[2].split(',');\n                var r = [];\n                for (var i = 0; i < parts.length; i++) {\n                    var p = parts[i].trim();\n                    if (!p) break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            } else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        } else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n    */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) {\n            return result.replace(pattern, ' ');\n        }, cssText);\n    };\n    // change a selector like 'div' to 'name div'\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector, slotSelector, commentOriginalSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var selector = rule.selector;\n            var content = rule.content;\n            if (rule.selector[0] !== '@') {\n                selector = _this._scopeSelector(rule.selector, scopeSelector, hostSelector, slotSelector, _this.strictStyling);\n            } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector, slotSelector, commentOriginalSelector);\n            }\n            selector = selector.replace(/\\s{2,}/g, ' ').trim();\n            return new CssRule(selector, content);\n        });\n    };\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, slotSelector, strict) {\n        var _this = this;\n        return selector.split(',').map(function (shallowPart) {\n            if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {\n                return shallowPart.trim();\n            }\n            if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                return strict ? _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector).trim() : _this._applySelectorScope(shallowPart, scopeSelector, hostSelector).trim();\n            } else {\n                return shallowPart.trim();\n            }\n        }).join(', ');\n    };\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var lre = /\\[/g;\n        var rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    // scope via name and [is=name]\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var replaceBy_1 = this.strictStyling ? \".\" + hostSelector : scopeSelector;\n            return selector.replace(_polyfillHostNoCombinatorRe, function (_, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            }).replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var className = '.' + scopeSelector;\n        var _scopeSelectorPart = function _scopeSelectorPart(p) {\n            var scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            } else {\n                // remove :host since it should be unnecessary\n                var t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + className + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var scopedSelector = '';\n        var startIndex = 0;\n        var res;\n        var sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        var shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            var separator = res[1];\n            var part_1 = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part_1.indexOf(_polyfillHostNoCombinator) > -1;\n            var scopedPart = shouldScope ? _scopeSelectorPart(part_1) : part_1;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        var part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        selector = selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost).replace(_colonSlottedRe, _polyfillSlotted);\n        return selector;\n    };\n    return ShadowCss;\n}();\nvar SafeSelector = /** @class */function () {\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (_, index) {\n            return _this.placeholders[+index];\n        });\n    };\n    SafeSelector.prototype.content = function () {\n        return this._content;\n    };\n    return SafeSelector;\n}();\nvar _polyfillHost = '-shadowcsshost';\nvar _polyfillSlotted = '-shadowcssslotted';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' + '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' + ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [/::shadow/g, /::content/g];\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonSlottedRe = /::slotted/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = /** @class */function () {\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}();\nfunction processRules(input, ruleCallback) {\n    var inputWithEscapedBlocks = escapeBlocks(input);\n    var nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var selector = m[2];\n        var content = '';\n        var suffix = m[4];\n        var contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = /** @class */function () {\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}();\nfunction escapeBlocks(input) {\n    var inputParts = input.split(_curlyRe);\n    var resultParts = [];\n    var escapedBlocks = [];\n    var bracketCount = 0;\n    var currentBlockParts = [];\n    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var part = inputParts[partIndex];\n        if (part === CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        } else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part === OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 3.chunk.ddf57.js","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts\n */\nfunction scopeCss(cssText, scopeId, commentOriginalSelector) {\n    var sc = new ShadowCss();\n    return sc.shimCssText(cssText, scopeId, scopeId + '-h', scopeId + '-s', commentOriginalSelector);\n}\nvar ShadowCss = /** @class */ (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    ShadowCss.prototype.shimCssText = function (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) {\n        if (hostScopeId === void 0) { hostScopeId = ''; }\n        if (slotScopeId === void 0) { slotScopeId = ''; }\n        if (commentOriginalSelector === void 0) { commentOriginalSelector = false; }\n        var commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        var orgSelectors = [];\n        if (commentOriginalSelector) {\n            var processCommentedSelector_1 = function (rule) {\n                var placeholder = \"/*!@___\" + orgSelectors.length + \"___*/\";\n                var comment = \"/*!@\" + rule.selector + \"*/\";\n                orgSelectors.push({ placeholder: placeholder, comment: comment });\n                rule.selector = placeholder + rule.selector;\n                return rule;\n            };\n            cssText = processRules(cssText, function (rule) {\n                if (rule.selector[0] !== '@') {\n                    return processCommentedSelector_1(rule);\n                }\n                else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                    rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                    rule.content = processRules(rule.content, processCommentedSelector_1);\n                    return rule;\n                }\n                return rule;\n            });\n        }\n        var scopedCssText = this._scopeCssText(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n        cssText = [scopedCssText].concat(commentsWithHash).join('\\n');\n        if (commentOriginalSelector) {\n            orgSelectors.forEach(function (_a) {\n                var placeholder = _a.placeholder, comment = _a.comment;\n                cssText = cssText.replace(placeholder, comment);\n            });\n        }\n        return cssText;\n    };\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) {\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertColonSlotted(cssText, slotScopeId);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeId) {\n            cssText = this._scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector);\n        }\n        cssText = cssText.replace(/-shadowcsshost-no-combinator/g, \".\" + hostScopeId);\n        cssText = cssText.replace(/>\\s*\\*\\s+([^{, ]+)/gm, ' $1 ');\n        return cssText.trim();\n    };\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n    */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /*\n   * convert a rule like ::slotted(.foo) { }\n  */\n    ShadowCss.prototype._convertColonSlotted = function (cssText, slotAttr) {\n        var regExp = _cssColonSlottedRe;\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var compound = m[2].trim();\n                var suffix = m[3];\n                var sel = '.' + slotAttr + ' > ' + compound + suffix;\n                return sel;\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n    */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var parts = m[2].split(',');\n                var r = [];\n                for (var i = 0; i < parts.length; i++) {\n                    var p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n    */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    // change a selector like 'div' to 'name div'\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector, slotSelector, commentOriginalSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var selector = rule.selector;\n            var content = rule.content;\n            if (rule.selector[0] !== '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, slotSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector, slotSelector, commentOriginalSelector);\n            }\n            selector = selector.replace(/\\s{2,}/g, ' ').trim();\n            return new CssRule(selector, content);\n        });\n    };\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, slotSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (shallowPart) {\n            if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {\n                return shallowPart.trim();\n            }\n            if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                return strict ?\n                    _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector).trim() :\n                    _this._applySelectorScope(shallowPart, scopeSelector, hostSelector).trim();\n            }\n            else {\n                return shallowPart.trim();\n            }\n        })\n            .join(', ');\n    };\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var lre = /\\[/g;\n        var rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    // scope via name and [is=name]\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var replaceBy_1 = this.strictStyling ? \".\" + hostSelector : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (_, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var className = '.' + scopeSelector;\n        var _scopeSelectorPart = function (p) {\n            var scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + className + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var scopedSelector = '';\n        var startIndex = 0;\n        var res;\n        var sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        var shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            var separator = res[1];\n            var part_1 = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part_1.indexOf(_polyfillHostNoCombinator) > -1;\n            var scopedPart = shouldScope ? _scopeSelectorPart(part_1) : part_1;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        var part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        selector = selector\n            .replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost)\n            .replace(_colonSlottedRe, _polyfillSlotted);\n        return selector;\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = /** @class */ (function () {\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (_, index) { return _this.placeholders[+index]; });\n    };\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _polyfillHost = '-shadowcsshost';\nvar _polyfillSlotted = '-shadowcssslotted';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g\n];\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonSlottedRe = /::slotted/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = /** @class */ (function () {\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\nfunction processRules(input, ruleCallback) {\n    var inputWithEscapedBlocks = escapeBlocks(input);\n    var nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var selector = m[2];\n        var content = '';\n        var suffix = m[4];\n        var contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = /** @class */ (function () {\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\nfunction escapeBlocks(input) {\n    var inputParts = input.split(_curlyRe);\n    var resultParts = [];\n    var escapedBlocks = [];\n    var bracketCount = 0;\n    var currentBlockParts = [];\n    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var part = inputParts[partIndex];\n        if (part === CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part === OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\nexport { ShadowCss, scopeCss };\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/widgettest/dist/esm/legacy/shadow-css-984bac74-549b16dd.js"],"sourceRoot":""}